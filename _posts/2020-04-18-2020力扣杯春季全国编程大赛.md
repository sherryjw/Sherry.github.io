---
title: 2020力扣杯春季全国编程大赛
tags: 算法
---

### **📝题目二**
```haskell
小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：

有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。

示例 1：

输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3

输出：3

解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。

示例 2：

输入：n = 3, relation = [[0,2],[2,1]], k = 2

输出：0

解释：信息不能从小 A 处经过 2 轮传递到编号 2
```
<br/>

### **📝思路**
🐣：递归🉑，赛的时候有点紧张没有快速解出😔。
<br/><br/>

### **📝题解**
```haskell
void pass(int n, vector<vector<int>>& relation, int k, int len, int cur_end, int& result){//这里的k是还需要再传递的次数
    if (k == 0){
        if (cur_end == n-1)
            ++result;
        return;
    }
    for (int i = 0; i < len; ++i){
        if (relation[i][0] == cur_end){
            pass(n, relation, k-1, len, relation[i][1], result);
        }
    }    
}

int numWays(int n, vector<vector<int>>& relation, int k) {
    int len = relation.size();
    int result = 0;
    pass(n, relation, k, len, 0, result);
    return result;
}
```

---

### **📝题目三**
```haskell
在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。

随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。

所有剧情的触发条件也用一个二维数组 requirements 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]，如果当前 C >= c[i] 且 R >= r[i] 且 H >= h[i] ，则剧情会被触发。

根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。

示例 1：

输入： increase = [[2,8,4],[2,5,0],[10,9,8]] requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]]

输出: [2,-1,3,-1]

解释：

初始时，C = 0，R = 0，H = 0

第 1 天，C = 2，R = 8，H = 4

第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0

第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2

剧情 1 和 3 无法触发。

示例 2：

输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]

输出: [-1,4,3,3,3]

示例 3：

输入： increase = [[1,1,1]] requirements = [[0,0,0]]

输出: [0]

限制：
· 1 <= increase.length <= 10000
· 1 <= requirements.length <= 100000
· 0 <= increase[i] <= 10
· 0 <= requirements[i] <= 100000
```
<br/>

### **📝思路**
最暴力的解法就是每一天累加后遍历requirements符合的就记录当前时间（在下太菜有限时间内也只想到了暴力法😤（甚至还另开数组记录时间😤😤<br/>

🐣：。
<br/><br/>

### **📝题解**
```haskell


```

（未完待续）