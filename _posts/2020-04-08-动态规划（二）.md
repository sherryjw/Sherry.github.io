---
title: 动态规划（二）
tags: 算法
---

<a href="#1121">soj 1121 --Tri Tiling</a><br/>

---

⭐⭐⭐⭐<a name="1121"></a>
```haskell
题号：soj 1121 --Tri Tiling
题目：用1*2的长方形铺满3*n的长方形，有多少种方法？（如下图）
```
![](https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.9/image/1121-0.png)<br/>
画图是最直截了当的解题关键：n=2时，可以平铺出矩形（3种情况）和非矩形（2种情况），如下图所示。<br/>
![](https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.9/image/1121-1.jpg)<br/>
![](https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.9/image/1121-2.jpg)<br/>
![](https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.9/image/1121-3.jpg)<br/>
那么可以转化为:
```haskell
要使3*n是一个矩形，有两种可能:
    1. 3*(n-2)也是一个矩形，那么只要再拼上一个3*2的就可以了。这个3*2有3种情况,所以是3*f(n-2);

    2. 3*(n-2)不是一个矩形，这种情况下，你只有一种添加2*1块的方法使得3*n是矩形，还需要对3*(n-4)的形状做判断：

        1. 3*(n-4)是一个矩形，那么只要再拼一个L形或者倒L形就可以使得3*(n-2)不是矩形了，这里就是2*f(n-4);

        2. 3*(n-4)不是一个矩形，那么也是只有一种添加2*1块的方法能使3*(n-2)不是矩形，接下来就来考虑3*(n-6)：

             1. 3*(n-6)是一个矩形，那么只要再拼一个L形或者倒L形就可以使得3*(n-4)不是矩形了，这里就是2*f(n-6);

             2. 3*(n-6)不是一个矩形，……
```
综上，可以得到递推式：**f(n) = 3 * f(n-2) + 2 * f(n-4) + 2 * f(n-6) + ... + 2 * f(0)**，其中初始值**f(0)=1**。
```haskell
#include <iostream>
using namespace std;

const int maxn = 30;
int f[maxn] = {0};

int dp(int n) {
	if (n % 2 == 1)	return 0;
	if (n == 0)	return f[0] = 1;
	if (n == 2)	return f[2] = 3;
	if (f[n] != 0)	return f[n];
	f[n] += 3 * dp(n - 2);
	for (int i = 2; i <= n/2; ++i) {
		f[n] += 2 * dp(n - 2 * i);
	}
	return f[n];
}

int main() {
	int n;
	while (cin >> n && n != -1) {
		cout << dp(n) << endl;
	}
}
```