---
title: åŠ¨æ€è§„åˆ’ï¼ˆäºŒï¼‰
tags: ç®—æ³•
---

<a href="#1121">soj 1121 --Tri Tiling</a><br/>
<a href="#1527">soj 1527 --Tiling a Grid With Dominoes</a><br/>
<a href="#1828">soj 1828 --Minimal</a><br/>

---
â­â­â­â­<a name="1121"></a>
```haskell
é¢˜å·ï¼šsoj 1121 --Tri Tiling
é¢˜ç›®ï¼šç”¨1*2çš„é•¿æ–¹å½¢é“ºæ»¡3*nçš„é•¿æ–¹å½¢ï¼Œæœ‰å¤šå°‘ç§æ–¹æ³•ï¼Ÿï¼ˆå¦‚ä¸‹å›¾ï¼‰
```
![](https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.9/image/1121-0.png)<br/>
åˆå§‹çŠ¶æ€ï¼Œn=2æ—¶ï¼Œå¯ä»¥å¹³é“ºå‡ºçŸ©å½¢ï¼ˆ3ç§æƒ…å†µï¼‰å’ŒéçŸ©å½¢ï¼ˆ2ç§æƒ…å†µï¼‰ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚<br/>
![](https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1121-1.png)<br/>
**é¢˜è§£ä¸€**ï¼šç”¨f[i]è¡¨ç¤ºé“ºæ»¡3*(2i)çš„é•¿æ–¹å½¢çš„æ–¹æ¡ˆæ•°ï¼Œç”¨g[i]è¡¨ç¤ºé“ºæ»¡3*(2i)çš„é•¿æ–¹å½¢ï¼Œå¹¶ä¸”å‘åä¼¸å±•å‡ºéƒ¨åˆ†å½¢çŠ¶çš„æ–¹æ¡ˆæ•°ã€‚åˆ™æœ‰ï¼š
- f[i]=3*f[i-1]+g[i-1]
  
3 * f[i-1]å³åœ¨f[i-1]çš„åŸºç¡€ä¸Šè¦åŠ ä¸Šæ°å¥½çš„3 * 2çŸ©å½¢æ‰èƒ½æ„æˆf[i]ï¼Œè€Œ3 * 2çŸ©å½¢æœ‰3ç§æƒ…å†µï¼ˆå¦‚ä¸Šå›¾ï¼‰ï¼›g[i-1]å³å¯¹äºæ¯ä¸€ç§éçŸ©å½¢éƒ½åªæœ‰ä¸€ç§æ–¹å¼å¯ä»¥å¡«è¡¥å…¶ä½¿ä¹‹æ°ä¸ºçŸ©å½¢ã€‚
- g[i]=2*f[i-1]+g[i-1]
  
2 * f[i-1]å³åœ¨f[i-1]çš„åŸºç¡€ä¸Šè¦åŠ ä¸Š2ç§éçŸ©å½¢ä¹‹ä¸€æ‰èƒ½æ„æˆg[i]ï¼›g[i-1]å³å¯¹äºæ¯ä¸€ç§éçŸ©å½¢éƒ½åªæœ‰ä¸€ç§æ–¹å¼å¯ä»¥å¡«è¡¥å…¶ä½¿ä¹‹æ°ä¸ºéçŸ©å½¢ã€‚
```haskell
#include <iostream>
using namespace std;

const int maxn = 32;
int f[maxn], g[maxn];

int dp(int n) {
	if (n % 2 == 1)	return 0;
	if (n == 0)	return f[0] = 1;
	f[1] = 3;
	g[1] = 2;
	int tmp = n / 2;
	for (int i = 2; i <= tmp; ++i) {
		f[i]=3*f[i-1]+g[i-1];
		g[i]=2*f[i-1]+g[i-1];
	}
	return f[tmp];
}

int main() {
	int n;
	while (cin >> n && n != -1) {
		cout << dp(n) << endl;
	}
}
```

**é¢˜è§£äºŒï¼šæ•°å­¦è§„å¾‹æ¨ç®—æ³•**
```haskell
è¦ä½¿3*næ˜¯ä¸€ä¸ªçŸ©å½¢ï¼Œæœ‰ä¸¤ç§å¯èƒ½:
    1. 3*(n-2)ä¹Ÿæ˜¯ä¸€ä¸ªçŸ©å½¢ï¼Œé‚£ä¹ˆåªè¦å†æ‹¼ä¸Šä¸€ä¸ª3*2çš„å°±å¯ä»¥äº†ã€‚è¿™ä¸ª3*2æœ‰3ç§æƒ…å†µ,æ‰€ä»¥æ˜¯3*f(n-2);

    2. 3*(n-2)ä¸æ˜¯ä¸€ä¸ªçŸ©å½¢ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œä½ åªæœ‰ä¸€ç§æ·»åŠ 2*1å—çš„æ–¹æ³•ä½¿å¾—3*næ˜¯çŸ©å½¢ï¼Œè¿˜éœ€è¦å¯¹3*(n-4)çš„å½¢çŠ¶åšåˆ¤æ–­ï¼š

    Â Â Â  1. 3*(n-4)æ˜¯ä¸€ä¸ªçŸ©å½¢ï¼Œé‚£ä¹ˆåªè¦å†æ‹¼ä¸€ä¸ªLå½¢æˆ–è€…å€’Lå½¢å°±å¯ä»¥ä½¿å¾—3*(n-2)ä¸æ˜¯çŸ©å½¢äº†ï¼Œè¿™é‡Œå°±æ˜¯2*f(n-4);

    Â Â Â  2. 3*(n-4)ä¸æ˜¯ä¸€ä¸ªçŸ©å½¢ï¼Œé‚£ä¹ˆä¹Ÿæ˜¯åªæœ‰ä¸€ç§æ·»åŠ 2*1å—çš„æ–¹æ³•èƒ½ä½¿3*(n-2)ä¸æ˜¯çŸ©å½¢ï¼Œæ¥ä¸‹æ¥å°±æ¥è€ƒè™‘3*(n-6)ï¼š

    Â Â Â Â Â Â Â Â  1. 3*(n-6)æ˜¯ä¸€ä¸ªçŸ©å½¢ï¼Œé‚£ä¹ˆåªè¦å†æ‹¼ä¸€ä¸ªLå½¢æˆ–è€…å€’Lå½¢å°±å¯ä»¥ä½¿å¾—3*(n-4)ä¸æ˜¯çŸ©å½¢äº†ï¼Œè¿™é‡Œå°±æ˜¯2*f(n-6);

    Â Â Â Â Â Â Â Â  2. 3*(n-6)ä¸æ˜¯ä¸€ä¸ªçŸ©å½¢ï¼Œâ€¦â€¦
```
ç»¼ä¸Šï¼Œå¯ä»¥å¾—åˆ°é€’æ¨å¼ï¼š**f(n) = 3 * f(n-2) + 2 * f(n-4) + 2 * f(n-6) + ... + 2 * f(0)**ï¼Œå…¶ä¸­åˆå§‹å€¼**f(0)=1**ã€‚
```haskell
#include <iostream>
using namespace std;

const int maxn = 30;
int f[maxn] = {0};

int dp(int n) {
	if (n % 2 == 1)	return 0;
	if (n == 0)	return f[0] = 1;
	if (n == 2)	return f[2] = 3;
	if (f[n] != 0)	return f[n];
	f[n] += 3 * dp(n - 2);
	for (int i = 2; i <= n/2; ++i) {
		f[n] += 2 * dp(n - 2 * i);
	}
	return f[n];
}

int main() {
	int n;
	while (cin >> n && n != -1) {
		cout << dp(n) << endl;
	}
}
```

---
â­â­â­â­â­<a name="1527"></a>
```haskell
é¢˜å·ï¼šsoj 1527 --Tiling a Grid With Dominoes
é¢˜ç›®ï¼šç”¨1*2çš„é•¿æ–¹å½¢é“ºæ»¡4*nçš„é•¿æ–¹å½¢ï¼Œæœ‰å¤šå°‘ç§æ–¹æ³•ï¼Ÿï¼ˆå¦‚ä¸‹å›¾ï¼‰
```
![](https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1527-0.png)<br/>
å¤„ç†æ–¹å¼ä¸ä¸Šé¢˜æœ‰äº›ç›¸ä¼¼ï¼Œä½†æ€è·¯æœ‰æ‰€ä¸åŒï¼šç”¨f[i][j]è¡¨ç¤ºå‰4*iåˆ—å·²ç»å®Œå…¨å¡«æ»¡ï¼Œå¹¶ä¸”ç¬¬(i+1)åˆ—æƒ…å†µä¸ºç¬¬jç§å½¢çŠ¶çš„æ–¹æ¡ˆæ•°ã€‚å…¶ä¸­ï¼Œå…±æœ‰5ç§å½¢çŠ¶ï¼Œåˆ†åˆ«æ˜¯ï¼š<br/>
![](https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1527-1.jpg)<br/>

```haskell
#include <iostream>
using namespace std;

const int maxn = 1001;
int f[maxn][5];

int dp(int N) {
	f[0][0] = f[1][0] = f[1][1] = f[1][3] = f[1][4] = 1;
	f[1][2] = 0;
	for (int i = 2; i <= N; ++i) {
		f[i][0] = f[i-2][0]+f[i-1][0]+f[i-1][1]+f[i-1][3]+f[i-1][4];
		f[i][1] = f[i-1][0]+f[i-1][4];
		f[i][2] = f[i-1][3];
		f[i][3] = f[i-1][0]+f[i-1][2];
		f[i][4] = f[i-1][0]+f[i-1][1];
	}
	return f[N][0];
}

int main() {
	int cases;
	cin >> cases;
	for (int i = 1; i <= cases; ++i) {
		int N;
		cin >> N;
		cout << i << " " << dp(N) << endl;
	}
}
```

---
â­â­â­<a name="1828"></a>
```haskell
é¢˜å·ï¼šsoj 1828 --Minimal
é¢˜ç›®ï¼šThere are two sets S1 and S2 subjecting to:
(1) S1, S2 are both the subsets of {x| x is an integer and 0 < x < 1,000,000}
(2) 0 < |S1| < |S2| < 500
 
F(S1, S2) = min {|a1-b1| + |a2-b2| + â€¦ + |aN-bN|} in which ai âˆˆS1, bi âˆˆS2, ai â‰ aj if iâ‰ j, bi â‰ bj if iâ‰ j (i, j = 1, 2 â€¦ Nï¼ŒN = |S1|)

For each test case, print the result of F(S1 ,S2).
```
æœ€å¼€å§‹æˆ‘çš„æƒ³æ³•æ˜¯ï¼Œå°†S1å’ŒS2ä½œç¬›å¡å°”ç§¯ï¼ˆå®šä¹‰Xä¸ºä¸¤æ•°å·®è·ï¼‰ï¼Œåœ¨ä¸€ä¸ªäºŒç»´æ•°ç»„é‡Œè®°å½•ä¸¤ä¸¤ä¹‹å·®çš„ç»å¯¹å€¼ï¼Œå¯¹S1æ¯ä¸ªå…ƒç´ éƒ½åŒ¹é…ä»¥S2æŸä¸ªå…ƒç´ ä½¿å¾—å·®è·å°½å¯èƒ½å°ã€‚**å°è¯•äº†å‡ ä¸ªæµ‹ä¾‹éƒ½è¿‡äº†ï¼Œä½†æ˜¯OJä¸Šé¢WAäº†ï¼Œè¿™ä¸ªè§£æ³•ä¸ªäººè§‰å¾—ä¹Ÿæœ‰äº›ç‰µå¼ºï¼Œæ— æ³•è¯æ˜ï¼Œä½†åˆæ— æ³•è¯ä¼ªğŸ˜­ã€‚**<br/>
<font color='gray'>< ä»¥ä¸‹è§£é‡Šå‚è€ƒç›¸å…³èµ„æ–™ä¿¡æ¯ ></font><br/>
å‡è®¾æˆ‘ä»¬ä»S2ä¸­é€‰æ‹©äº†æŸäº›æ•°ï¼Œå‡è®¾é€‰å‡ºçš„æ•°ç»„æˆS3ï¼Œé‚£ä¹ˆS3ä¸­æœ€å°çš„æ•°è‚¯å®šåŒ¹é…S1ä¸­æœ€å°çš„æ•°ï¼ŒS3ä¸­æ¬¡å°çš„æ•°åŒ¹é…S1ä¸­æ¬¡å°çš„æ•°â€¦
```haskell
è¯æ˜ï¼š
å‡è®¾S1ä¸­æœ‰äº†a1,a2,S3ä¸­æœ‰b1,b2
ä¸”a1<=a2,b1<=b2
é‚£ä¹ˆæœ‰|a1-b1|+|a2-b2|<=|a1-b2|+|a2-b1|ï¼ˆæ•°å­¦é—®é¢˜ï¼‰
æ‰€ä»¥ä»å°åˆ°å¤§ä¸€ä¸ªä¸ªåŒ¹é…ä¸ä¼šæ›´å·®ï¼Œåªä¼šæ›´å¥½ã€‚
```
**è§£æ³•ï¼š**<br/>
å¯¹S1å’ŒS2åˆ†åˆ«ä»å°åˆ°å¤§æ’åºï¼Œç”¨f[i][j]è¡¨ç¤ºS1ä¸­çš„å‰iä¸ªæ•°ï¼Œä¸S2ä¸­çš„å‰jä¸ªæ•°åŒ¹é…ï¼ˆä»jä¸ªæ•°é€‰iä¸ªæ•°å‡ºæ¥ï¼‰ï¼Œæ˜¾ç„¶æœ‰ï¼š<br/>
```haskell
f[i][j] = inf(j < i)
f[0][0] = 0
f[i][j] = min{f[i-1][j-1]+|a[i]-b[j]|,f[i][j-1]},j>=i
```
ä»£ç å¦‚ä¸‹ï¼š
```haskell
#include <iostream>
#include <algorithm>
using namespace std;

#define inf 1<<30
const int maxn = 501;
int f[maxn][maxn];
int S1[maxn], S2[maxn];

int main() {
	int cases;
	cin >> cases;
	while (cases--) {
		int N, M;
		cin >> N >> M;
		for (int i = 1; i <= N; ++i) {
			cin >> S1[i];
		}
		for (int i = 1; i <= M; ++i) {
			cin >> S2[i];
		}

		sort(S1+1, S1+N+1);
		sort(S2+1, S2+M+1);
		for (int i = 0; i <= N; ++i) {
			for (int j = 0; j <= M; ++j) {
				if (i == 0 && j == 0)
					f[i][j] = 0;
				else if (i > j) {
					f[i][j] = inf;
				}
				else {
					f[i][j] = inf;
					if (i > 0)
						f[i][j] = min(f[i][j], f[i-1][j-1]+abs(S1[i]-S2[j]));
					if (j > 0)
						f[i][j] = min(f[i][j], f[i][j-1]);
				}
			}
		}
		cout << f[N][M] << endl;
	}
}
```

ï¼ˆæœªå®Œå¾…ç»­ï¼‰